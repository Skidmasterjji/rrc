getgenv().Exodus = {
["Chat"] = {
Enabled = false, -- // No Point Of Adding A Customizable "Commands" Example "." or "!" not wasting my time
Circle = "Silent", -- // "Silent" or "Aimbot"
CircleSize = "sfov",
Prediction = "Silent", -- // "Silent" or "Aimbot"
PredictionAmount = "spred",
},
["Startup"] = {
Intro = true, -- // will show a intro
SerialKey = "ur_key_here" -- // ur whitelist key
},
["Aimbot"] = {
Enabled = false,
Keybinds = "q",
Locking = false, -- // don't touch
["Predicting"] = {
Prediction = false,
PredictionAmmount = 0
},
["Smoothing"] = {
Smoothness = false,
SmoothnessAmmount = 0
},
["Shaking"] = {
Shake = false,
ShakeAmmount = 0.7
},
["Hitparts"] = {
AimpartType = "Basic", -- // "Basic", "Nearest Part", "Nearest Point"
Aimpart = "HumanoidRootPart",
BasicAimpart = "HumanoidRootPart",
IgnorePart = true,
IgnoredParts = {"RightFoot", "LeftFoot"}
},
["Resolving"] = {
Resolver = false,
ResolverType = "When Velocity is too high",
PosResolverMax = 100,
NegResolverMax = 100
},
["FOV"] = {
ShowFOV = false,
DynamicAmmount = 0,
FOVType = "static", -- // "Dynamic", "Static"
FOVRadius = 100,
Filled = false,
Sides = 25,
Thickness = 1,
Transparency = 1,
Color = Color3.fromRGB(0, 0, 0)
},
["Checks"] = {
UseYAxis = false,
WallCheck = false,
VisibleCheck = false,
ForceFieldCheck = false,
SelfAliveCheck = false,
TargetKOCheck = false,
GrabbedCheck = false,
CrewCheck = false,
IsInFOVCheck = false,
SelfReloadCheck = false,
FirstPersonOnly = false,
AllowThirdPersonShiftLock = false,
ThirdPersonOnly = false
}
},
["SilentAim"] = {
Enabled = false,
Keybinds = "p",
["Predicting"] = {
PredictionAmmount = 0
},
["Hitparts"] = {
AimpartType = "Basic", -- // "Basic", "Nearest Part", "Nearest Point"
Aimpart = "HumanoidRootPart",
BasicAimpart = "HumanoidRootPart",
IgnorePart = true,
IgnoredParts = {"LeftFoot", "RightFoot"}
},
["Resolving"] = {
Resolver = false,
ResolverType = "When Velocity is too high",
PosResolverMax = 100,
NegResolverMax = 100
},
["FOV"] = {
ShowFOV = false,
FOVRadius = 100,
FOVType = "Static", -- // "Dynamic", "Static"
FOVType2 = "Cursor",
DynamicAmmount = 0,
Filled = false,
Sides = 25,
Thickness = 1,
Transparency = 1,
Color = Color3.fromRGB(0, 0, 0)
},
["Checks"] = {
HitChance = 100,
UseYAxis = false,
SelfAliveCheck = false,
SelfReloadCheck = false,
IsInFOVCheck = false,
GrabbedCheck = false,
ForceFieldCheck = false,
TargetCrew = false,
WallCheck = false,
TargetKOCheck = false
}
}
}

-- Setup and initial configuration
getgenv().wass = {
    TriggerBot = false,
    TriggerBot_Delay = 1,
    TriggerRadius = 10,
    TriggerFOV = 7,
    TriggerDistance = 500,
    ShowFOV = false,
    KnifeCheck = false, -- Add KnifeCheck flag
}

local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera
local Drawing = Drawing or nil

local function GetMagnitudeFromMouse(targetPart)
    local targetScreenPos, onScreen = Camera:WorldToViewportPoint(targetPart.Position)
    local mousePos = UserInputService:GetMouseLocation()
    if onScreen then
        return (Vector2.new(targetScreenPos.X, targetScreenPos.Y) - mousePos).Magnitude
    end
    return math.huge
end

local function IsInFOV(targetPart)
    local direction = (targetPart.Position - Camera.CFrame.Position).Unit
    local cameraDirection = Camera.CFrame.LookVector
    local angle = math.deg(math.acos(direction:Dot(cameraDirection)))
    return angle <= wass.TriggerFOV
end

local FOVCircle
if wass.ShowFOV and Drawing then
    FOVCircle = Drawing.new("Circle")
    FOVCircle.Thickness = 1
    FOVCircle.Radius = wass.TriggerRadius
    FOVCircle.Color = Color3.fromRGB(255, 255, 255)
    FOVCircle.Filled = false
    FOVCircle.Transparency = 0.5
end

local function Click()
    local character = LocalPlayer.Character
    if character then
        local tool = character:FindFirstChildWhichIsA("Tool")
        if tool then
            tool:Activate()
        end
    end
end

getgenv().Keybinds = getgenv().Keybinds or {}
Keybinds.TriggerBot = Keybinds.TriggerBot or Enum.KeyCode.F3 -- Default to 'T' key if not set

-- Add your other code here...
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera
local Drawing = Drawing or nil

-- Your other functions and setup code...

-- UserInputService listener to toggle TriggerBot with the keybind
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == Keybinds.TriggerBot then
        wass.TriggerBot = not wass.TriggerBot
    end
end)

-- Knife check logic: disable TriggerBot if holding a "[Knife]"
local function CheckKnifeEquipped()
    local character = LocalPlayer.Character
    if character then
        local tool = character:FindFirstChildWhichIsA("Tool")
        if tool and tool.Name == "[Knife]" then
            -- Disable TriggerBot if holding a "[Knife]"
            wass.TriggerBot = false
        else
            -- Re-enable TriggerBot if "[Knife]" is not equipped
            if not wass.TriggerBot then
                wass.TriggerBot = true
            end
        end
    end
end

-- Main logic for TriggerBot
RunService.RenderStepped:Connect(function()
    if wass.KnifeCheck then
        CheckKnifeEquipped() -- Check for knife every frame
    end

    if not wass.TriggerBot then return end

    local closestTarget = nil
    local closestDistance = math.huge

    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            for _, part in ipairs(player.Character:GetDescendants()) do
                if part:IsA("BasePart") then
                    local screenMagnitude = GetMagnitudeFromMouse(part)
                    local distanceFromCamera = (part.Position - Camera.CFrame.Position).Magnitude

                    if screenMagnitude < wass.TriggerRadius and IsInFOV(part) and distanceFromCamera <= wass.TriggerDistance and screenMagnitude < closestDistance then
                        closestDistance = screenMagnitude
                        closestTarget = part
                    end
                end
            end
        end
    end

    if closestTarget then
        if wass.TriggerBot_Delay == 0 then
            Click()
        else
            task.spawn(function()
                task.wait(wass.TriggerBot_Delay / 1000)
                Click()
            end)
        end
    end

    if wass.ShowFOV and FOVCircle then
        FOVCircle.Position = UserInputService:GetMouseLocation()
        FOVCircle.Radius = wass.TriggerRadius
        FOVCircle.Visible = true
    end
end)

local library = loadstring(game:HttpGet("https://raw.githubusercontent.com/Skidmasterjji/rrc/refs/heads/main/lib"))()

-- Initialize the window using the library
local window = library:init("STELLAR", true, Enum.KeyCode.Insert, true)

window:Divider("Aiming")

-- Create a section for test elements
local sectionA = window:Section("Camlock")
local sectionB = window:Section("Silent Aim")
local sectionC = window:Section("Checks")
local sectionD = window:Section("Ahk")
sectionA:Divider("Camlock")

-- Ensure `Exodus` and necessary tables are initialized
if not getgenv().Exodus then
    getgenv().Exodus = {}
end

-- Initialize SilentAim and FOV if not already initialized
if not getgenv().Exodus["SilentAim"] then
    getgenv().Exodus["SilentAim"] = { FOV = { ShowFOV = false } }
end

-- Initialize Aimbot and Predicting if not already initialized
if not getgenv().Exodus["Aimbot"] then
    getgenv().Exodus["Aimbot"] = { Enabled = true, Predicting = { Prediction = false, PredictionAmmount = 0.1365 } }
end

-- Keybinds initialization
local Keybinds = {
    Aimbot = Enum.KeyCode.Q,
    SilentAim = Enum.KeyCode.X
}

-- Switch to toggle "Aimbot Enabled"
sectionA:Switch("Enable", getgenv().Exodus["Aimbot"].Enabled, function(a)
    -- Toggle the Enabled state for Aimbot
    getgenv().Exodus["Aimbot"].Enabled = a
    

end)

-- Textbox to input new keybind for Aimbot
sectionA:TextField("Keybind", tostring(Keybinds.Aimbot), function(input)
    -- Try to convert the input to an Enum.KeyCode value
    local keybind = Enum.KeyCode[input:match("^[a-zA-Z]+$"):upper()]  -- Ensure case-insensitive conversion

    if keybind then
        -- Update the keybind if the input is valid
        Keybinds.Aimbot = keybind
    end
end)
-- Switch to toggle "Smoothing"
sectionA:Switch("Smoothing", getgenv().Exodus["Aimbot"]["Smoothing"].Smoothness, function(a)
    -- Toggle the Smoothness state
    getgenv().Exodus["Aimbot"]["Smoothing"].Smoothness = a

end)

-- Textbox to adjust "Smoothness"
sectionA:TextField("Smoothness", tostring(getgenv().Exodus["Aimbot"]["Smoothing"].SmoothnessAmmount), function(input)
    -- Convert the input to a number
    local smoothnessAmount = tonumber(input)
    
    if smoothnessAmount then
        -- Update the Smoothness Amount if it's a valid number
        getgenv().Exodus["Aimbot"]["Smoothing"].SmoothnessAmmount = smoothnessAmount
    end
end)

-- Switch to toggle "Prediction"
sectionA:Switch("Predict", getgenv().Exodus["Aimbot"]["Predicting"].Prediction, function(a)
    -- Toggle the Prediction state
    getgenv().Exodus["Aimbot"]["Predicting"].Prediction = a
    

end)

-- Textbox to adjust "Prediction"
sectionA:TextField("Prediction", tostring(getgenv().Exodus["Aimbot"]["Predicting"].PredictionAmmount), function(input)
    -- Convert the input to a number
    local predictionAmount = tonumber(input)
    
    if predictionAmount then
        -- Update the Prediction Amount if it's a valid number
        getgenv().Exodus["Aimbot"]["Predicting"].PredictionAmmount = predictionAmount
    end
end)

-- Switch to toggle "Nearest Point"
sectionA:Switch("Nearest Point", getgenv().Exodus["Aimbot"]["Hitparts"].AimpartType == "Nearest Point", function(a)
    if a then
        -- Set AimpartType to "Nearest Point" when toggled on
        getgenv().Exodus["Aimbot"]["Hitparts"].AimpartType = "Nearest Point"
    else
        -- Set AimpartType to "Basic" or whatever default you prefer
        getgenv().Exodus["Aimbot"]["Hitparts"].AimpartType = "Basic"
    end

    -- Optionally print the new state for debugging
end)

-- Textbox to adjust "FOV Radius"
sectionA:TextField("Fov Size", tostring(getgenv().Exodus["Aimbot"]["FOV"].FOVRadius), function(input)
    -- Convert the input to a number
    local fovRadius = tonumber(input)
    
    if fovRadius then
        -- Update the FOVRadius if it's a valid number
        getgenv().Exodus["Aimbot"]["FOV"].FOVRadius = fovRadius
    end
end)

-- Switch to toggle "FOV Type Dynamic"
sectionA:Switch("Range/Dynamic Fov", getgenv().Exodus["Aimbot"]["FOV"].FOVType == "Dynamic", function(a)
    -- Change the FOVType to Dynamic if the toggle is on, else Static
    getgenv().Exodus["Aimbot"]["FOV"].FOVType = a and "Dynamic" or "Static"

end)

-- Textbox to adjust "DynamicAmmount"
sectionA:TextField("Dynamic Power", tostring(getgenv().Exodus["Aimbot"]["FOV"].DynamicAmmount), function(input)
    -- Convert the input to a number
    local dynamicAmmount = tonumber(input)
    
    if dynamicAmmount then
        -- Update the DynamicAmmount if it's a valid number
        getgenv().Exodus["Aimbot"]["FOV"].DynamicAmmount = dynamicAmmount

    end
end)


-- Switch to toggle "Resolver"
sectionA:Switch("Resolver", getgenv().Exodus["Aimbot"]["Resolving"].Resolver, function(a)
    -- Toggle the Resolver state
    getgenv().Exodus["Aimbot"]["Resolving"].Resolver = a

    -- Optionally print the new state for debugging
end)

-- Textbox to adjust "MaxPositionOffset"
sectionA:TextField("MaxPositionOffset", tostring(getgenv().Exodus["Aimbot"]["Resolving"].PosResolverMax), function(input)
    -- Convert the input to a number
    local posResolverMax = tonumber(input)

    if posResolverMax then
        -- Update PosResolverMax if it's a valid number
        getgenv().Exodus["Aimbot"]["Resolving"].PosResolverMax = posResolverMax
    end
end)

-- Textbox to adjust "NegResolverMax"
sectionA:TextField("MinPositionOffset", tostring(getgenv().Exodus["Aimbot"]["Resolving"].NegResolverMax), function(input)
    -- Convert the input to a number
    local negResolverMax = tonumber(input)

    if negResolverMax then
        -- Update NegResolverMax if it's a valid number
        getgenv().Exodus["Aimbot"]["Resolving"].NegResolverMax = negResolverMax
    end
end)
sectionA:Switch("Show Fov", getgenv().Exodus["Aimbot"]["FOV"].ShowFOV, function(a)
    -- Toggle the ShowFOV state
    getgenv().Exodus["Aimbot"]["FOV"].ShowFOV = a
    
    -- Optionally print the new state for debugging
end)


sectionC:Divider("Camlock Checks")
local checks = getgenv().Exodus["Aimbot"]["Checks"]

sectionC:Switch("Self Death Check", checks.SelfAliveCheck, function(state)
    getgenv().Exodus["Aimbot"]["Checks"].SelfAliveCheck = state
end)
sectionC:Switch("Wall Check", checks.WallCheck, function(state)
    getgenv().Exodus["Aimbot"]["Checks"].WallCheck = state
end)
sectionC:Switch("Target Death Check", checks.TargetKOCheck, function(state)
    getgenv().Exodus["Aimbot"]["Checks"].TargetKOCheck = state
end)

sectionC:Switch("Use Y Axis", checks.UseYAxis, function(state)
    getgenv().Exodus["Aimbot"]["Checks"].UseYAxis = state
end)

sectionC:Switch("Forcefield Check", checks.ForceFieldCheck, function(state)
    getgenv().Exodus["Aimbot"]["Checks"].ForceFieldCheck = state
end)

sectionC:Switch("Grabbed Check", checks.GrabbedCheck, function(state)
    getgenv().Exodus["Aimbot"]["Checks"].GrabbedCheck = state
end)

sectionC:Switch("Crew Check", checks.CrewCheck, function(state)
    getgenv().Exodus["Aimbot"]["Checks"].CrewCheck = state
end)

sectionC:Divider("Silent Aim Checks")
sectionB:Divider("Silent Aim")
-- Create a text field for "Hit Chance"
sectionC:TextField("Hit Chance", tostring(getgenv().Exodus["SilentAim"]["Checks"].HitChance), function(input)
    -- Convert the input to a number
    local hitChance = tonumber(input)
    
    -- Check if the input is a valid number
    if hitChance then
        -- Update the HitChance value in the table
        getgenv().Exodus["SilentAim"]["Checks"].HitChance = hitChance
    end
end)

-- Create a toggle for "Wall Check"
sectionC:Switch("Wall Check", getgenv().Exodus["SilentAim"]["Checks"].WallCheck, function(state)
    getgenv().Exodus["SilentAim"]["Checks"].WallCheck = state
end)

-- Create a toggle for "Target KO Check"
sectionC:Switch("Target KO Check", getgenv().Exodus["SilentAim"]["Checks"].TargetKOCheck, function(state)
    getgenv().Exodus["SilentAim"]["Checks"].TargetKOCheck = state
end)

-- Create a toggle for "Target Crew"
sectionC:Switch("Target Crew", getgenv().Exodus["SilentAim"]["Checks"].TargetCrew, function(state)
    getgenv().Exodus["SilentAim"]["Checks"].TargetCrew = state
end)

-- Create a toggle for "Grabbed Check"
sectionC:Switch("Grabbed Check", getgenv().Exodus["SilentAim"]["Checks"].GrabbedCheck, function(state)
    getgenv().Exodus["SilentAim"]["Checks"].GrabbedCheck = state
end)

-- Create a toggle for "ForceField Check"
sectionC:Switch("ForceField Check", getgenv().Exodus["SilentAim"]["Checks"].ForceFieldCheck, function(state)
    getgenv().Exodus["SilentAim"]["Checks"].ForceFieldCheck = state
end)

-- Create a toggle for "Use Y Axis"
sectionC:Switch("Use Y Axis", getgenv().Exodus["SilentAim"]["Checks"].UseYAxis, function(state)
    -- Update the corresponding value in the table when toggled
    getgenv().Exodus["SilentAim"]["Checks"].UseYAxis = state
end)

local silentAim = getgenv().Exodus["SilentAim"]

-- Create a toggle for "Enable Silent Aim"
sectionB:Switch("Enable Silent Aim", silentAim.Enabled, function(state)
    -- Update the corresponding value in the table when toggled
    getgenv().Exodus["SilentAim"].Enabled = state
end)

sectionB:TextField("Keybind", tostring(Keybinds.SilentAim), function(input)
    -- Try to convert the input to an Enum.KeyCode value
    local keybind = Enum.KeyCode[input:match("^[a-zA-Z]+$"):upper()]  -- Ensure case-insensitive conversion

    if keybind then
        -- Update the keybind if the input is valid
        Keybinds.SilentAim = keybind
    else
        -- If the input is not a valid keybind, show an error message
    end
end)


sectionB:TextField("Prediction", tostring(getgenv().Exodus["SilentAim"]["Predicting"].PredictionAmmount), function(input)
    -- Convert the input to a number
    local predictionAmount = tonumber(input)
    
    -- Check if the input is a valid number
    if predictionAmount then
        -- Update the PredictionAmmount value in the table
        getgenv().Exodus["SilentAim"]["Predicting"].PredictionAmmount = predictionAmount
    else
        -- Show an error message if the input is invalid
    end
end)

-- Switch to toggle "Nearest Point"
sectionB:Switch("Nearest Point", getgenv().Exodus["SilentAim"]["Hitparts"].AimpartType == "Nearest Point", function(a)
    if a then
        -- Set AimpartType to "Nearest Point" when toggled on
        getgenv().Exodus["SilentAim"]["Hitparts"].AimpartType = "Nearest Point"
    else
        -- Set AimpartType to "Basic" or whatever default you prefer
        getgenv().Exodus["SilentAim"]["Hitparts"].AimpartType = "Basic"
    end
end)
-- Switch to toggle "Show FOV"
sectionB:Switch("Show FOV", getgenv().Exodus["SilentAim"]["FOV"].ShowFOV, function(a)
    -- Set ShowFOV based on the switch state
    getgenv().Exodus["SilentAim"]["FOV"].ShowFOV = a
end)

sectionB:TextField("FOV Size", tostring(getgenv().Exodus["SilentAim"]["FOV"].FOVRadius), function(input)
    -- Convert the input to a number
    local fovRadius = tonumber(input)
    
    -- Check if the input is a valid number
    if fovRadius then
        -- Update the FOVRadius value in the table
        getgenv().Exodus["SilentAim"]["FOV"].FOVRadius = fovRadius
    else
        -- Show an error message if the input is invalid
    end
end)

-- Switch to toggle "FOV Type Dynamic"
sectionB:Switch("Dynamic/Range Fov", getgenv().Exodus["SilentAim"]["FOV"].FOVType == "Dynamic", function(a)
    -- Change the FOVType to Dynamic if the toggle is on, else Static
    getgenv().Exodus["SilentAim"]["FOV"].FOVType = a and "Dynamic" or "Static"
end)

-- Textbox to adjust "DynamicAmmount"
sectionB:TextField("Dynamic Power", tostring(getgenv().Exodus["SilentAim"]["FOV"].DynamicAmmount), function(input)
    -- Convert the input to a number
    local dynamicAmmount = tonumber(input)
    
    if dynamicAmmount then
        -- Update the DynamicAmmount if it's a valid number
        getgenv().Exodus["SilentAim"]["FOV"].DynamicAmmount = dynamicAmmount
    else
        -- If the input is not a valid number, show an error message
    end
end)

-- Switch to toggle "Resolver"
sectionB:Switch("Enable Resolver", getgenv().Exodus["SilentAim"]["Resolving"].Resolver, function(a)
    -- Toggle the Resolver state
    getgenv().Exodus["SilentAim"]["Resolving"].Resolver = a
end)

-- Textbox to adjust "PosResolverMax"
sectionB:TextField("PosResolverMax", tostring(getgenv().Exodus["SilentAim"]["Resolving"].PosResolverMax), function(input)
    -- Convert the input to a number
    local posResolverMax = tonumber(input)

    if posResolverMax then
        -- Update PosResolverMax if it's a valid number
        getgenv().Exodus["SilentAim"]["Resolving"].PosResolverMax = posResolverMax
    else
        -- If the input is not a valid number, show an error message
    end
end)

-- Textbox to adjust "NegResolverMax"
sectionB:TextField("NegResolverMax", tostring(getgenv().Exodus["SilentAim"]["Resolving"].NegResolverMax), function(input)
    -- Convert the input to a number
    local negResolverMax = tonumber(input)

    if negResolverMax then
        -- Update NegResolverMax if it's a valid number
        getgenv().Exodus["SilentAim"]["Resolving"].NegResolverMax = negResolverMax
    else
        -- If the input is not a valid number, show an error message
    end
end)
sectionD:Divider("Triggerbot")
sectionD:Switch("Enable TriggerBot", wass.TriggerBot, function(state)
    wass.TriggerBot = state
end)
sectionD:TextField("TriggerBot Keybind", tostring(Keybinds.TriggerBot), function(input)
    -- Try to convert the input to an Enum.KeyCode value
    local keybind = Enum.KeyCode[input:match("^[a-zA-Z]+$"):upper()]  -- Ensure case-insensitive conversion

    if keybind then
        -- Update the keybind if the input is valid
        Keybinds.TriggerBot = keybind

    end
end)

-- Textbox for TriggerBot Delay
sectionD:TextField("TriggerBot Delay", tostring(wass.TriggerBot_Delay), function(input)
    local delay = tonumber(input)
    if delay then
        wass.TriggerBot_Delay = delay
    else
    end
end)

-- Textbox for TriggerRadius
sectionD:TextField("Fov Size", tostring(wass.TriggerRadius), function(input)
    local radius = tonumber(input)
    if radius then
        wass.TriggerRadius = radius

    end
end)

sectionD:Switch("Show FOV", wass.ShowFOV, function(state)
    wass.ShowFOV = state

    -- If Show FOV is enabled, create or update the FOV circle
    if state then
        if not FOVCircle then
            FOVCircle = Drawing.new("Circle")
            FOVCircle.Thickness = 1
            FOVCircle.Color = Color3.fromRGB(255, 255, 255)
            FOVCircle.Filled = false
            FOVCircle.Transparency = 0.5
        end
    else
        if FOVCircle then
            FOVCircle.Visible = false
        end
    end
end)
-- Toggle for KnifeCheck
sectionD:Switch("Enable Knife Check", wass.KnifeCheck, function(state)
    wass.KnifeCheck = state
end)

-- Textbox for TriggerDistance
sectionD:TextField("Trigger Distance", tostring(wass.TriggerDistance), function(input)
    local distance = tonumber(input)
    if distance then
        wass.TriggerDistance = distance
    end
end)



script_key = getgenv().Exodus.Startup.SerialKey

local Players = game:GetService("Players")
local LP = Players["LocalPlayer"]
while not LP do
Players["ChildAdded"]:Wait()
LP = Players["LocalPlayer"]
end
local Char = LP["Character"]
while not Char do
LP["CharacterAdded"]:Wait()
Char = LP["Character"]
end

local Services = {
Workspace = game:GetService("Workspace"),
RunService = game:GetService("RunService"),
Players = game:GetService("Players"),
UserInputService = game:GetService("UserInputService"),
GuiService = game:GetService("GuiService"),
ReplicatedStorage = game:GetService("ReplicatedStorage")
}

local Local = {
Player = Services.Players.LocalPlayer,
Camera = Services.Workspace.CurrentCamera,
Mouse = Services.Players.LocalPlayer:GetMouse()
}

local AimlockTarget, RootPartPosition, Real_Magnitude, vis, ray, ignoreList, part, Velocity, Main, feign,
AimlockTargetName, SilentTarget, Aimplace, SilentVelocity, CurrentPosition, Time, Distance, SilCurrentPosition,
SilTime, SilDistance, pos, ac, idk

game:GetService("RunService").RenderStepped:Connect(function()
    if wass.ShowFOV and FOVCircle then
        -- Update FOVCircle's position and size based on mouse position and TriggerRadius
        local mousePos = game:GetService("UserInputService"):GetMouseLocation()
        FOVCircle.Position = mousePos
        FOVCircle.Radius = wass.TriggerRadius
        FOVCircle.Visible = true
    end
end)

local Player = game:GetService("Players").LocalPlayer
local Mouse = Player:GetMouse()
local SilPreviousPosition = Vector3.new()
local PreviousPosition = Vector3.new()

local CamCircle = Drawing.new("Circle")
CamCircle.Color = getgenv().Exodus.Aimbot.FOV.Color
CamCircle.Thickness = getgenv().Exodus.Aimbot.FOV.Thickness
CamCircle.Transparency = getgenv().Exodus.Aimbot.FOV.Transparency
CamCircle.Radius = getgenv().Exodus.Aimbot.FOV.FOVRadius
CamCircle.Visible = getgenv().Exodus.Aimbot.FOV.ShowFOV
CamCircle.Filled = getgenv().Exodus.Aimbot.FOV.Filled

local SilentCircle = Drawing.new("Circle")
SilentCircle.Visible = getgenv().Exodus.SilentAim.FOV.ShowFOV
SilentCircle.Transparency = getgenv().Exodus.SilentAim.FOV.Transparency
SilentCircle.Radius = getgenv().Exodus.SilentAim.FOV.FOVRadius
SilentCircle.Thickness = getgenv().Exodus.SilentAim.FOV.Thickness
SilentCircle.Color = getgenv().Exodus.SilentAim.FOV.Color
SilentCircle.Filled = getgenv().Exodus.SilentAim.FOV.Filled

local function IsOnScreen(a, Setting)
if Setting.VisibleCheck then
local _, vis = Services.Workspace.CurrentCamera:WorldToScreenPoint(a.Position)
if vis then
return true
else
return false
end
else
return true
end
end

local function WallCheck(a, Setting)
if Setting.WallCheck then
ray = Ray.new(Local.Camera.CFrame.Position, a.HumanoidRootPart.Position - Local.Camera.CFrame.Position)
ignoreList = {Local.Player.Character, a.Parent}
part = Services.Workspace:FindPartOnRayWithIgnoreList(ray, ignoreList)
if not part then
return true
end
return false
else
return true
end
end

local function IsInRadius(a, Setting)
if Setting.IsInFOVCheck then
for _, v in pairs(a:GetChildren()) do
if (v:IsA("Part") or v:IsA("MeshPart")) and v.Name ~= "HumanoidRootPart" then
local pos = Local.Camera:WorldToViewportPoint(v.Position)
local dis = (Vector2.new(Local.Mouse.X, Local.Mouse.Y) - Vector2.new(pos.X, pos.Y)).Magnitude
if dis < SilentCircle.Radius then
return true
end
elseif v:IsA("Accessory") then
local pos = Local.Camera:WorldToViewportPoint(v.Handle.Position)
local dis = (Vector2.new(Local.Mouse.X, Local.Mouse.Y) - Vector2.new(pos.X, pos.Y)).Magnitude
if dis < SilentCircle.Radius then
return true
end
end
end
return false
else
return true
end
end

local function GrabbedCheck(a, Setting)
if Setting.GrabbedCheck then
if a:FindFirstChild("GRABBING_CONSTRAINT") ~= nil then
return false
else
return true
end
else
return true
end
end

local function getClosestPartToCursor(a, Setting)
local closestPart
local shortestDistance = math.huge
if Setting.IgnorePart then
for _, v in pairs(a:GetChildren()) do
if (not table.find(Setting.IgnoredParts, v.Name)) then
if v:IsA("Part") or v:IsA("MeshPart") then
local WrldToViewportPointP = Services.Workspace.CurrentCamera:WorldToScreenPoint(v.Position)
local Distance = (Vector2.new(WrldToViewportPointP.X, WrldToViewportPointP.Y) -
Vector2.new(Local.Mouse.X, Local.Mouse.Y)).Magnitude
if Distance < shortestDistance then
shortestDistance = Distance
closestPart = v
end
end
end
end
return closestPart
elseif not Setting.IgnorePart then
for _, v in next, a:GetChildren() do
if v:IsA("Part") or v:IsA("MeshPart") then
local WrldToViewportPointP = Services.Workspace.CurrentCamera:WorldToScreenPoint(v.Position)
local Distance = (Vector2.new(WrldToViewportPointP.X, WrldToViewportPointP.Y) -
Vector2.new(Local.Mouse.X, Local.Mouse.Y)).Magnitude
if Distance < shortestDistance then
shortestDistance = Distance
closestPart = v
end
end
end
return closestPart
end
end

local function getClosestPointOnPart(Part)
local mouseray = Local.Mouse.UnitRay
mouseray = mouseray.Origin + (mouseray.Direction * (Part.Position - mouseray.Origin).Magnitude)
local point =
(mouseray.Y >= (Part.Position - Part.Size / 2).Y and mouseray.Y <= (Part.Position + Part.Size / 2).Y) and
(Part.Position + Vector3.new(0, -Part.Position.Y + mouseray.Y, 0)) or Part.Position
local check = RaycastParams.new()
check.FilterType = Enum.RaycastFilterType.Whitelist
check.FilterDescendantsInstances = {Part}
local ray = Services.Workspace:Raycast(mouseray, (point - mouseray), check)
if ray then
return ray.Position
else
return Local.Mouse.Hit.Position
end
end

local function SelfAlive(Setting)
if game.PlaceId == 12442317726 then
if Setting.SelfAliveCheck then
if Local.Player.Character:FindFirstChild("BodyEffects")["KO"].Value == false then
return true
else
return false
end
else
return true
end
else
if Setting.SelfAliveCheck then

if Local.Player.Character:FindFirstChild("BodyEffects")["K.O"].Value == false then
return true
else
return false
end
else
return true
end
end
end

local function TargetKO(a, Setting)
if game.PlaceId == 10355218822 or game.PlaceId == 12154107359 then
if Setting.TargetKOCheck then
if a:FindFirstChild("DEAD") ~= nil or a.Health < 3 then
return false
else
return true
end
else
return true
end
elseif game.PlaceId == 12442317726 then
if Setting.TargetKOCheck then
if a:FindFirstChild("BodyEffects")["KO"].Value == false then
return true
else
return false
end
else
return true
end
else
if Setting.TargetKOCheck then
if a:FindFirstChild("BodyEffects")["K.O"].Value == false then
return true
else
return false
end
else
return true
end
end
end

local function SilentHitChance()
if math.random(0, 100) <= getgenv().Exodus.SilentAim.Checks.HitChance then
return true
else
return false
end
end

local function TargetForceField(a, Setting)
if Setting.ForceFieldCheck then
if not (a:FindFirstChildOfClass("ForceField")) then
return true
else
return false
end
else
return true
end
end

local function SelfReload(Setting)
if Setting.SelfReloadCheck then
if game.PlaceId ~= 9825515356 then
if Local.Player.Character.BodyEffects.Reload.Value == false then
return true
else
return false
end
else
if Local.Player.Character.BodyEffects.Reloading.Value == false then
return true
else
return false
end
end
else
return true
end
end

local function TargetCrew(b, Setting)
if Setting.CrewCheck then
if Local.Player.DataFolder.Information:FindFirstChild('Crew').Value ~= "" and
Services.Players[b].DataFolder.Information:FindFirstChild('Crew').Value ~= "" then
if Local.Player.DataFolder.Information.Crew.Value ~= Services.Players[b].DataFolder.Information.Crew.Value then
return true
else
return false
end
else
return true
end
else
return true
end
end

local function IsInFirstPerson(Setting)
if Setting.FirstPersonOnly and Setting.AllowThirdPersonShiftLock == false then
if (Local.Camera.CFrame.p - Local.Camera.Focus.p).Magnitude < 0.7 then
return true
else
return false
end
elseif Setting.FirstPersonOnly and Setting.AllowThirdPersonShiftLock then
if (Local.Camera.CFrame.p - Local.Camera.Focus.p).Magnitude < 0.7 or Services.UserInputService.MouseBehavior ==
Enum.MouseBehavior.LockCenter then
return true
else
return false
end
end
return true
end

local function IsInThirdPerson(Setting)
if Setting.ThirdPersonOnly then
if (Local.Camera.CFrame.p - Local.Camera.Focus.p).Magnitude > 0.7 then
return true
else
return false
end
end
return true
end

local function aimbot(feign)
if getgenv().Exodus.Aimbot.Smoothing.Smoothness then
Local.Camera.CFrame = Local.Camera.CFrame:Lerp(Main, getgenv().Exodus.Aimbot.Smoothing.SmoothnessAmmount,
Enum.EasingStyle.Quad, Enum.EasingDirection.Out, Enum.EasingStyle.Quad, Enum.EasingDirection.In)
end
end

local function getClosestPlayerToCursor(Setting)
local Target, Closest = nil, 1 / 0
for _, v in pairs(Services.Players:GetPlayers()) do
if (v.Character and v ~= Local.Player and v.Character:FindFirstChild("HumanoidRootPart")) and
IsOnScreen(v.Character:FindFirstChild("HumanoidRootPart"), getgenv().Exodus.SilentAim) and
WallCheck(v.Character, getgenv().Exodus.SilentAim) then
local Position, OnScreen = Local.Camera:WorldToScreenPoint(v.Character.HumanoidRootPart.Position)
local Distance = (Vector2.new(Position.X, Position.Y) - Vector2.new(Local.Mouse.X, Local.Mouse.Y)).Magnitude
if (Setting > Distance and Distance < Closest and OnScreen) then
Closest = Distance
Target = v
end
end
end
return Target
end

Services.UserInputService.InputBegan:Connect(function(input)
if not (Services.UserInputService:GetFocusedTextBox()) then
if input.KeyCode == Keybinds.Aimbot and AimlockTarget == nil then
if getgenv().Exodus.Aimbot.Locking ~= true then
getgenv().Exodus.Aimbot.Locking = true
end
local Target;
if game.PlaceId == 10355218822 or game.PlaceId == 12154107359 then
if Target ~= nil then
AimlockTarget = Services.Workspace.NPC.Dummy
AimlockTargetName = Services.Workspace.NPC.Dummy.Name
end
else
Target = getClosestPlayerToCursor(700)
if Target ~= nil then
AimlockTarget = Target.Character
AimlockTargetName = Target.Name
end
end

elseif input.KeyCode == Keybinds.Aimbot and AimlockTarget ~= nil then
if AimlockTarget ~= nil then
AimlockTarget = nil
end
if getgenv().Exodus.Aimbot.Locking ~= false then
getgenv().Exodus.Aimbot.Locking = false
end
end
end
end)

if not LPH_OBFUSCATED then
LPH_JIT_MAX = function(...)
return ...
end
end

local Velocity = nil;
local lastPosition = Vector3.new(0, 0, 0)
local lastTime = tick()
local SilentlastPosition = Vector3.new(0, 0, 0)
local SilentlastTime = tick()

Services.RunService.Heartbeat:Connect(LPH_JIT_MAX(function()
if getgenv().Exodus.Aimbot.Enabled == true and getgenv().Exodus.Aimbot.Locking == true and AimlockTarget and
AimlockTarget:FindFirstChild(getgenv().Exodus.Aimbot.Hitparts.Aimpart) then
if getgenv().Exodus.Aimbot.FOV.ShowFOV then
CamCircle.Radius = getgenv().Exodus.Aimbot.FOV.FOVRadius
CamCircle.Visible = getgenv().Exodus.Aimbot.FOV.ShowFOV
CamCircle.Position = Vector2.new(Services.UserInputService:GetMouseLocation().X,
Services.UserInputService:GetMouseLocation().Y)
elseif getgenv().Exodus.Aimbot.FOV.ShowFOV == false then
if CamCircle.Visible ~= false then
CamCircle.Visible = getgenv().Exodus.Aimbot.FOV.ShowFOV
end
end
if getgenv().Exodus.Aimbot.Hitparts.AimpartType == "Basic" then
getgenv().Exodus.Aimbot.Hitparts.Aimpart = getgenv().Exodus.Aimbot.Hitparts.BasicAimpart
end
if getgenv().Exodus.Aimbot.Hitparts.AimpartType == "Nearest Part" then
getgenv().Exodus.Aimbot.Hitparts.Aimpart = tostring(
getClosestPartToCursor(AimlockTarget, getgenv().Exodus.Aimbot))
end
if getgenv().Exodus.Aimbot.FOV.FOVType == "Dynamic" then
if Local.Player.Character:FindFirstChild("HumanoidRootPart") then
feign = (Local.Camera.CFrame.Position - AimlockTarget.HumanoidRootPart.Position).magnitude
getgenv().Exodus.Aimbot.FOV.FOVRadius = (getgenv().Exodus.Aimbot.FOV.DynamicAmmount / feign)
end
end
if SelfAlive(getgenv().Exodus.Aimbot.Checks) and TargetKO(AimlockTarget, getgenv().Exodus.Aimbot.Checks) and
IsOnScreen(AimlockTarget[getgenv().Exodus.Aimbot.Hitparts.Aimpart], getgenv().Exodus.Aimbot.Checks) and
WallCheck(AimlockTarget, getgenv().Exodus.Aimbot.Checks) and
IsInRadius(AimlockTarget, getgenv().Exodus.Aimbot.Checks) and
TargetForceField(AimlockTarget, getgenv().Exodus.Aimbot.Checks) and
TargetCrew(AimlockTargetName, getgenv().Exodus.Aimbot.Checks) and SelfReload(getgenv().Exodus.Aimbot.Checks) and
IsInFirstPerson(getgenv().Exodus.Aimbot.Checks) and IsInThirdPerson(getgenv().Exodus.Aimbot.Checks) and
GrabbedCheck(AimlockTarget, getgenv().Exodus.Aimbot.Checks) and
AimlockTarget:FindFirstChild("HumanoidRootPart") then
if getgenv().Exodus.Aimbot.Hitparts.AimpartType == "Nearest Part" or
getgenv().Exodus.Aimbot.Hitparts.AimpartType == "Basic" then
ac = AimlockTarget[getgenv().Exodus.Aimbot.Hitparts.Aimpart].Position
elseif getgenv().Exodus.Aimbot.Hitparts.AimpartType == "Nearest Point" then
getgenv().Exodus.Aimbot.Hitparts.Aimpart = tostring(
getClosestPartToCursor(AimlockTarget, getgenv().Exodus.Aimbot))
ac = getClosestPointOnPart(AimlockTarget[getgenv().Exodus.Aimbot.Hitparts.Aimpart])
end
pcall(function()
local currentPosition = AimlockTarget.HumanoidRootPart.Position
local currentTime = tick()
local deltaPos = currentPosition - lastPosition
local deltaTime = currentTime - lastTime
if getgenv().Exodus.Aimbot.Resolving.Resolver then
if getgenv().Exodus.Aimbot.Resolving.ResolverType == "When Velocity is too high" then
if (AimlockTarget.HumanoidRootPart.Velocity).magnitude >
getgenv().Exodus.Aimbot.Resolving.PosResolverMax or
(AimlockTarget.HumanoidRootPart.Velocity).magnitude <
-getgenv().Exodus.Aimbot.Resolving.NegResolverMax then
if deltaTime >= 0.03 then
Velocity = deltaPos / deltaTime
lastPosition = currentPosition
lastTime = currentTime
end
if getgenv().Exodus.Aimbot.Checks.UseYAxis == false then
Velocity = Vector3.new(Velocity.X, 0, Velocity.Z)
end
else
if getgenv().Exodus.Aimbot.Checks.UseYAxis == false then
Velocity = Vector3.new(AimlockTarget.HumanoidRootPart.Velocity.X, 0,
AimlockTarget.HumanoidRootPart.Velocity.Z)
else
Velocity = AimlockTarget.HumanoidRootPart.Velocity
end
end
else
if deltaTime >= 0.03 then
Velocity = deltaPos / deltaTime
lastPosition = currentPosition
lastTime = currentTime
end
if getgenv().Exodus.Aimbot.Checks.UseYAxis == false then
Velocity = Vector3.new(Velocity.X, 0, Velocity.Z)
end
end
else
if getgenv().Exodus.Aimbot.Checks.UseYAxis == false then
Velocity = Vector3.new(AimlockTarget.HumanoidRootPart.Velocity.X, 0,
AimlockTarget.HumanoidRootPart.Velocity.Z)
else
Velocity = AimlockTarget.HumanoidRootPart.Velocity
end
end
if getgenv().Exodus.Aimbot.Shaking.Shake then
if getgenv().Exodus.Aimbot.Predicting.Prediction then
Main = CFrame.new(Local.Camera.CFrame.p, ac +
Vector3.new(
math.random(-getgenv().Exodus.Aimbot.Shaking.ShakeAmmount,
getgenv().Exodus.Aimbot.Shaking.ShakeAmmount) * 0.01,
math.random(-getgenv().Exodus.Aimbot.Shaking.ShakeAmmount,
getgenv().Exodus.Aimbot.Shaking.ShakeAmmount) * 0.1, math.random(
-getgenv().Exodus.Aimbot.Shaking.ShakeAmmount,
getgenv().Exodus.Aimbot.Shaking.ShakeAmmount) * 0.1) +
(Vector3.new(Velocity.X, Velocity.Y, Velocity.Z)) *
getgenv().Exodus.Aimbot.Predicting.PredictionAmmount)
else
Main = CFrame.new(Local.Camera.CFrame.p, ac +
Vector3.new(
math.random(-getgenv().Exodus.Aimbot.Shaking.ShakeAmmount,
getgenv().Exodus.Aimbot.Shaking.ShakeAmmount) * 0.01,
math.random(-getgenv().Exodus.Aimbot.Shaking.ShakeAmmount,
getgenv().Exodus.Aimbot.Shaking.ShakeAmmount) * 0.1, math.random(
-getgenv().Exodus.Aimbot.Shaking.ShakeAmmount,
getgenv().Exodus.Aimbot.Shaking.ShakeAmmount) * 0.1))
end
else
if getgenv().Exodus.Aimbot.Predicting.Prediction then
Main = CFrame.new(Local.Camera.CFrame.p,
ac + (Vector3.new(Velocity.X, Velocity.Y, Velocity.Z)) *
getgenv().Exodus.Aimbot.Predicting.PredictionAmmount)
else
Main = CFrame.new(Local.Camera.CFrame.p, ac)
end
end
if getgenv().Exodus.Aimbot.Smoothing.Smoothness then
aimbot(Main)
else
if getgenv().Exodus.Aimbot.Predicting.Prediction then
Local.Camera.CFrame = CFrame.new(Local.Camera.CFrame.Position, ac +
(Vector3.new(Velocity.X, Velocity.Y, Velocity.Z)) *
getgenv().Exodus.Aimbot.Predicting.PredictionAmmount)
else
Local.Camera.CFrame = CFrame.new(Local.Camera.CFrame.Position, ac)
end
end
end)
end
else
getgenv().Exodus.Aimbot.Locking = false
AimlockTarget = nil
CamCircle.Visible = false
end
if getgenv().Exodus.SilentAim.Enabled then
SilentTarget = getClosestPlayerToCursor(700)
if SilentTarget and SilentTarget.Character and SilentTarget.Character:FindFirstChild("HumanoidRootPart") then
pcall(function()
local SilentcurrentPosition = SilentTarget.Character.HumanoidRootPart.Position
local SilentcurrentTime = tick()
local SilentdeltaPos = SilentcurrentPosition - SilentlastPosition
local SilentdeltaTime = SilentcurrentTime - SilentlastTime
if getgenv().Exodus.SilentAim.Resolving.Resolver then
if getgenv().Exodus.SilentAim.ResolverType == "When Velocity is too high" then
if (SilentTarget.Character.HumanoidRootPart.Velocity).magnitude >
getgenv().Exodus.SilentAim.Resolving.PosResolverMax or
(SilentTarget.Character.HumanoidRootPart.Velocity).magnitude <
-getgenv().Exodus.SilentAim.Resolving.NegResolverMax then
if SilentdeltaTime >= 0.03 then
SilentVelocity = SilentdeltaPos / SilentdeltaTime
SilentlastPosition = SilentcurrentPosition
SilentlastTime = SilentcurrentTime
end
if getgenv().Exodus.SilentAim.Checks.UseYAxis == false then
SilentVelocity = Vector3.new(SilentVelocity.X, 0, SilentVelocity.Z)
end
else
if getgenv().Exodus.SilentAim.Checks.UseYAxis == false then
SilentVelocity = Vector3.new(SilentTarget.Character.HumanoidRootPart.Velocity.X, 0,
SilentTarget.Character.HumanoidRootPart.Velocity.Z)
else
SilentVelocity = SilentTarget.Character.HumanoidRootPart.Velocity
end
end
else
if SilentdeltaTime >= 0.03 then
SilentVelocity = SilentdeltaPos / SilentdeltaTime
SilentlastPosition = SilentcurrentPosition
SilentlastTime = SilentcurrentTime
end
if getgenv().Exodus.SilentAim.Checks.UseYAxis == false then
SilentVelocity = Vector3.new(Velocity.X, 0, Velocity.Z)
end
end
else
if getgenv().Exodus.SilentAim.Checks.UseYAxis == false then
SilentVelocity = Vector3.new(SilentTarget.Character.HumanoidRootPart.Velocity.X, 0,
SilentTarget.Character.HumanoidRootPart.Velocity.Z)
else
SilentVelocity = SilentTarget.Character.HumanoidRootPart.Velocity
end
end
if getgenv().Exodus.SilentAim.Hitparts.AimpartType == "Nearest Part" then
getgenv().Exodus.SilentAim.Hitparts.Aimpart =
tostring(getClosestPartToCursor(SilentTarget.Character, getgenv().Exodus.SilentAim))
Aimplace = (SilentTarget.Character[getgenv().Exodus.SilentAim.Hitparts.Aimpart].Position) +
(SilentVelocity * getgenv().Exodus.SilentAim.Predicting.PredictionAmmount)
elseif getgenv().Exodus.SilentAim.Hitparts.AimpartType == "Basic" then
getgenv().Exodus.SilentAim.Hitparts.Aimpart = getgenv().Exodus.SilentAim.Hitparts.BasicAimpart
Aimplace = (SilentTarget.Character[getgenv().Exodus.SilentAim.Hitparts.Aimpart].Position) +
(SilentVelocity * getgenv().Exodus.SilentAim.Predicting.PredictionAmmount)
elseif getgenv().Exodus.SilentAim.Hitparts.AimpartType == "Nearest Point" then
getgenv().Exodus.SilentAim.Hitparts.Aimpart =
tostring(getClosestPartToCursor(SilentTarget.Character, getgenv().Exodus.SilentAim))
Aimplace = (getClosestPointOnPart(
SilentTarget.Character[getgenv().Exodus.SilentAim.Hitparts.Aimpart]) +
(SilentVelocity * getgenv().Exodus.SilentAim.Predicting.PredictionAmmount))
end
end)
end
if getgenv().Exodus.SilentAim.FOV.ShowFOV then
SilentCircle.Radius = getgenv().Exodus.SilentAim.FOV.FOVRadius
if getgenv().Exodus.SilentAim.FOV.FOVType2 == "Cursor" then
SilentCircle.Visible = getgenv().Exodus.SilentAim.FOV.ShowFOV
SilentCircle.Position = Vector2.new(Local.Mouse.X, Local.Mouse.Y + Services.GuiService:GetGuiInset().Y)
else
if SilentTarget then
local PlayerPosition = SilentTarget.Character.HumanoidRootPart.Position + SilentVelocity *
getgenv().Exodus.SilentAim.Predicting.PredictionAmmount
local OnScreenPosition = Local.Camera:WorldToViewportPoint(PlayerPosition)
SilentCircle.Position = (Vector2.new(OnScreenPosition.X, OnScreenPosition.Y))
SilentCircle.Visible = getgenv().Exodus.SilentAim.FOV.ShowFOV
else
SilentCircle.Visible = false
end
end
else
SilentCircle.Visible = getgenv().Exodus.SilentAim.FOV.ShowFOV
end
if SilentTarget and SilentTarget.Character and SilentTarget.Character.HumanoidRootPart then
if getgenv().Exodus.SilentAim.FOV.FOVType == "Dynamic" then
if Local.Player.Character:FindFirstChild("HumanoidRootPart") then
idk = (Local.Camera.CFrame.Position - SilentTarget.Character.HumanoidRootPart.Position).magnitude
getgenv().Exodus.SilentAim.FOV.FOVRadius = (getgenv().Exodus.SilentAim.FOV.DynamicAmmount / idk)
end
end
end
else
if SilentCircle.Visible ~= false then
SilentCircle.Visible = false
end
end
end))

local function GetArgument()
for _, Player in next, game:GetService("Players"):GetPlayers() do
if Player.Backpack:GetAttribute(string.upper("muv")) then
return Player.Backpack:GetAttribute(string.upper("muv"))
end
end

return nil
end

local function getgamesnamecall()
if game.PlaceId == 2788229376 or game.PlaceId == 4106313503 or game.PlaceId == 12442317726 then
return "UpdateMousePos"
elseif game.PlaceId == 5602055394 or game.PlaceId == 7951883376 then
return "MousePos"
elseif game.PlaceId == 9825515356 then
return "GetMousePos"
else
return GetArgument()
end
end

local function MainEventLocate()
for _, v in pairs(Services.ReplicatedStorage:GetChildren()) do
if v.Name == "MainEvent" then
return v
end
end
end

local function SilentActivator(Place)
if getgenv().Exodus.SilentAim.Enabled then
if SilentTarget and SilentTarget.Character and SilentVelocity then
if TargetKO(SilentTarget.Character, getgenv().Exodus.SilentAim.Checks) and
IsOnScreen(SilentTarget.Character[getgenv().Exodus.SilentAim.Hitparts.Aimpart],
getgenv().Exodus.SilentAim.Checks) and
WallCheck(SilentTarget.Character, getgenv().Exodus.SilentAim.Checks) and
IsInRadius(SilentTarget.Character, getgenv().Exodus.SilentAim.Checks) and
TargetForceField(SilentTarget.Character, getgenv().Exodus.SilentAim.Checks) and
TargetCrew(SilentTarget.Name, getgenv().Exodus.SilentAim.Checks) and
GrabbedCheck(SilentTarget.Character, getgenv().Exodus.SilentAim.Checks) and
SilentTarget.Character:FindFirstChild("HumanoidRootPart") then
MainEventLocate():FireServer(getgamesnamecall(), Place)
end
end
end
end

Local.Player.Character.ChildAdded:Connect(LPH_JIT_MAX(function(tool)
if tool:IsA("Tool") and
(tool:FindFirstChild("Script") or tool:FindFirstChild("GunScript") or tool:FindFirstChild("weaponInfo")) then
tool.Activated:Connect(function()
SilentActivator(Aimplace)
end)
end
end))
getgenv().Exodus["Chat"].Enabled = true

game.Players.LocalPlayer.Chatted:Connect(function(message)
if getgenv().Exodus["Chat"].Enabled then
local args = string.split(message, " ")

-- Change SilentAim FOV (even if ShowFOV is false)
if args[1] == getgenv().Exodus["Chat"].CircleSize and getgenv().Exodus["Chat"].Circle == "Silent" and args[2] ~= nil then
local newFOV = tonumber(args[2])
getgenv().Exodus["SilentAim"]["FOV"].FOVRadius = newFOV
SilentCircle.Radius = newFOV -- ✅ Forces an update


-- Change Aimbot FOV (even if ShowFOV is false)
elseif args[1] == getgenv().Exodus["Chat"].CircleSize and getgenv().Exodus["Chat"].Circle == "Aimbot" and args[2] ~= nil then
local newFOV = tonumber(args[2])
getgenv().Exodus["Aimbot"]["FOV"].FOVRadius = newFOV
CamCircle.Radius = newFOV -- ✅ Forces an update

end

-- Change Prediction Amount
if args[1] == getgenv().Exodus["Chat"].PredictionAmount and args[2] ~= nil then
local newPrediction = tonumber(args[2])
if getgenv().Exodus["Chat"].Prediction == "Silent" then
getgenv().Exodus["SilentAim"]["Predicting"].PredictionAmmount = newPrediction
elseif getgenv().Exodus["Chat"].Prediction == "Aimbot" then
getgenv().Exodus["Aimbot"]["Predicting"].PredictionAmmount = newPrediction

end
end
end
end)


Local.Player.CharacterAdded:Connect(LPH_JIT_MAX(function(Character)
Character.ChildAdded:Connect(function(tool)
if tool:IsA("Tool") and
(tool:FindFirstChild("Script") or tool:FindFirstChild("GunScript") or tool:FindFirstChild("weaponInfo")) then
tool.Activated:Connect(function()
SilentActivator(Aimplace)
end)
end
end)
end))

Services.UserInputService.InputBegan:Connect(LPH_JIT_MAX(function(input)
if not (Services.UserInputService:GetFocusedTextBox()) then
if input.KeyCode == Keybinds.SilentAim then
if getgenv().Exodus.SilentAim.Enabled then
getgenv().Exodus.SilentAim.Enabled = false
elseif getgenv().Exodus.SilentAim.Enabled == false then
getgenv().Exodus.SilentAim.Enabled = true
end
end
end
end))

wait(0.5)

if getgenv().Exodus.Startup.Intro then
local Tracer = Drawing.new("Image")
local Blur = Instance.new("BlurEffect")
local screenSize = Services.Workspace.CurrentCamera.ViewportSize
local centerPosition = Vector2.new(screenSize.X / 2, screenSize.Y / 2)
Tracer.Position = centerPosition
Tracer.Size = Vector2.new(0, 0)
Tracer.Visible = true
Tracer.Data = game:HttpGet("https://i.ibb.co/dcFvJVx/Vision-2-PFP-2-copie.png")
Blur.Size = 0
Blur.Parent = Services.Workspace.CurrentCamera
for i = 1, 100 do
Tracer.Size = Tracer.Size + (Vector2.new(540, 540) - Tracer.Size) / 20
Tracer.Position = centerPosition - Tracer.Size / 2
if Blur.Size ~= 10 then
Blur.Size = Blur.Size + 1
end
task.wait()
end
Tracer.Size = Vector2.new(540, 540)
Tracer.Position = centerPosition - Tracer.Size / 2
wait(0.75)
for i = 1, 85 do
if Tracer.Transparency ~= 0 then
Tracer.Transparency = Tracer.Transparency - 0.01
end
if Blur.Size ~= 0 then
Blur.Size = Blur.Size - 1
end
task.wait()
end
Tracer.Size = Vector2.new(0, 0)
Blur:Destroy()
end
