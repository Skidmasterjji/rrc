-- // Silent Aim for Da Hood without using UpdateMousePos or Mouse.Hit
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local Workspace = game:GetService("Workspace")
local Camera = Workspace.CurrentCamera

-- Configuration
local Config = {
    Enabled = true,
    PredictionVelocity = 0.165,   -- Adjust prediction value to fine-tune accuracy
    Part = "Head",                -- Body part to aim at
    ClosestToCrosshair = true,    -- Find target closest to crosshair
    Humanize = true,              -- Add slight randomness to aiming for a more human feel
    HumanizeValue = Vector3.new(0.1, 0.1, 0.1) -- Randomization values for humanizing aim
}

-- Function to get the closest target to the crosshair
local function getClosestTarget()
    local closestTarget = nil
    local closestDistance = math.huge

    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild(Config.Part) then
            local part = player.Character[Config.Part]
            local screenPoint, onScreen = Camera:WorldToViewportPoint(part.Position)
            local distance = (Vector2.new(screenPoint.X, screenPoint.Y) - Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)).Magnitude

            if onScreen and distance < closestDistance then
                closestDistance = distance
                closestTarget = player
            end
        end
    end

    return closestTarget
end

-- Function to calculate aim position
local function calculateAimPosition()
    if Config.Enabled then
        local SilentTarget = getClosestTarget()
        if SilentTarget and SilentTarget.Character and SilentTarget.Character:FindFirstChild(Config.Part) then
            local targetPart = SilentTarget.Character[Config.Part]
            local targetPosition = targetPart.Position

            -- Predict movement by adding target velocity
            local velocity = SilentTarget.Character:FindFirstChild("HumanoidRootPart") and SilentTarget.Character.HumanoidRootPart.Velocity or Vector3.new(0, 0, 0)
            targetPosition = targetPosition + (velocity * Config.PredictionVelocity)

            -- Humanize aim with slight random offset if enabled
            if Config.Humanize then
                targetPosition = targetPosition + Vector3.new(
                    math.random() * Config.HumanizeValue.X - Config.HumanizeValue.X / 2,
                    math.random() * Config.HumanizeValue.Y - Config.HumanizeValue.Y / 2,
                    math.random() * Config.HumanizeValue.Z - Config.HumanizeValue.Z / 2
                )
            end

            return targetPosition
        end
    end
    return nil
end

-- Function to simulate shooting at the silent aim target
local function shootAtTarget()
    local aimPosition = calculateAimPosition()
    if aimPosition then
        -- Simulate a shot going to the calculated aim position
        -- This should replace where your game usually handles shooting or raycasting

        -- Example: Cast a ray to the target position
        local origin = Camera.CFrame.Position
        local direction = (aimPosition - origin).Unit * 500  -- Adjust ray length as needed

        local raycastParams = RaycastParams.new()
        raycastParams.FilterDescendantsInstances = {LocalPlayer.Character}
        raycastParams.FilterType = Enum.RaycastFilterType.Blacklist

        local result = Workspace:Raycast(origin, direction, raycastParams)

        if result then
            print("Hit: ", result.Instance)
            -- Handle hit effect, damage application, etc. based on result.Instance
        else
            print("Missed")
        end
    end
end

-- Use `shootAtTarget` instead of the usual shooting logic to direct shots with silent aim
RunService.RenderStepped:Connect(function()
    if Config.Enabled then
        shootAtTarget()
    end
end)
